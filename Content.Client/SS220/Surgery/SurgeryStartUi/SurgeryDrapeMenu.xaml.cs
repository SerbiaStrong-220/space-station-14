// Â© SS220, An EULA/CLA with a hosting restriction, full text: https://raw.githubusercontent.com/SerbiaStrong-220/space-station-14/master/CLA.txt

using Content.Client.UserInterface.Controls;
using Content.Shared.SS220.Surgery;
using Content.Shared.SS220.Surgery.Graph;
using Content.Shared.SS220.Surgery.Systems;
using Robust.Client.AutoGenerated;
using Robust.Client.Player;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.CustomControls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;
using Robust.Shared.Utility;

namespace Content.Client.SS220.Surgery.SurgeryStartUi;

[GenerateTypedNameReferences]
public sealed partial class SurgeryDrapeMenu : FancyWindow
{
    [Dependency] private readonly IEntityManager _entityManager = default!;
    [Dependency] private readonly IPlayerManager _player = default!;

    private readonly SharedSurgerySystem _surgery = default!;

    public event Action<ProtoId<SurgeryGraphPrototype>, EntityUid>? OnSurgeryConfirmClicked;

    public EntityUid Target;
    public EntityUid Used;

    private Dictionary<SurgeryPuppetPart, HashSet<Control>> _operations = new();

    private const SurgeryPuppetPart SelectedOnStartPart = SurgeryPuppetPart.Torso;
    private const int ControlsInitAllocateNumber = 8;

    public SurgeryDrapeMenu()
    {
        IoCManager.InjectDependencies(this);
        RobustXamlLoader.Load(this);

        _surgery = _entityManager.System<SharedSurgerySystem>();

        Puppet.Initialize();

        Puppet.SelectedPartChanged += (part, prevPart) =>
        {
            OperationsLabel.Text = LocPuppetPartPath(part);
            UpdateOperations(part, prevPart);
        };

        _operations.Clear(); // never knows what coming after all
        foreach (var part in Enum.GetValues<SurgeryPuppetPart>())
        {
            _operations.Add(part, new(ControlsInitAllocateNumber));
        }

        Puppet.SelectedPart = SelectedOnStartPart;
    }

    public void UpdateOperations(SurgeryPuppetPart? currentPart, SurgeryPuppetPart? previousPart)
    {
        if (previousPart != null)
        {
            foreach (var control in _operations[previousPart.Value])
            {
                control.Visible = false;
            }
        }
        if (currentPart != null)
        {
            foreach (var control in _operations[currentPart.Value])
            {
                control.Visible = true;
            }
        }
    }

    public void AddOperations(List<SurgeryGraphPrototype> graphPrototypes)
    {
        foreach (var val in _operations.Values)
        {
            val.Clear();
        }

        if (_player.LocalEntity is not {} performer)
            return;

        foreach (var graph in graphPrototypes)
        {
            var button = MakeOperationButton(graph, performer);

            OperationContainer.AddChild(button);
            SetFormattedText(button.RichTextLabel, graph.Name);

            button.Visible = graph.TargetPart == Puppet.SelectedPart;

            _operations[graph.TargetPart].Add(button);
        }
    }

    public void UpdateTarget(EntityUid target)
    {
        Target = target;
        Title = Loc.GetString("surgery-start-ui-target", ("target", target));
    }

    private SurgeryPerformButton MakeOperationButton(SurgeryGraphPrototype surgeryGraph, EntityUid performer)
    {
        var button = new SurgeryPerformButton(surgeryGraph.ID)
        {
            StyleClasses = { "OpenBoth" },
        };

        button.OnPressed += (_) =>
        {
            // So wee do something if button was pressed before pressing by player.
            // Thats why it !Pressed, but meant to be If pressed pressed than
            if (!button.Pressed)
                OnSurgeryConfirmClicked?.Invoke(button.GraphId, Target);
            else
                FooterLeft.Text = Loc.GetString("surgery-footer-confirm");

        };

        button.OnMouseEntered += (_) =>
        {
            var formattedText = FormattedMessage.FromMarkupPermissive(Loc.GetString(surgeryGraph.Description));

            if (surgeryGraph.Postscript != null)
            {
                formattedText.PushNewline();
                var postscriptMessage = Loc.GetString(surgeryGraph.Postscript);
                formattedText.AddMessage(FormattedMessage.FromMarkupPermissive(postscriptMessage));
            }
        };

        if (!_surgery.CanStartSurgery(performer, surgeryGraph, Target, Used, out var reason))
        {
            var tooltip = new Tooltip();
            SetFormattedText(tooltip, reason);
            button.TooltipSupplier = (_) => tooltip;
        }
        else
        {
            button.TooltipSupplier = (_) => null;
        }

        return button;
    }

    private string LocPuppetPartPath(SurgeryPuppetPart? part)
    {
        if (part == null)
            return "surgery-puppet-part-none";
        return $"surgery-puppet-part-{Enum.GetName(typeof(SurgeryPuppetPart), part)!}";
    }

    /// <summary>
    /// Some helper function to easily set formatted message from locPath
    /// </summary>
    private void SetFormattedText(Action<FormattedMessage> setterFormatted, Action<string> setterString, string locPath)
    {
        var loc = Loc.GetString(locPath);
        if (FormattedMessage.TryFromMarkup(loc, out var msg))
            setterFormatted(msg);
        else
            setterString(loc);
    }

    private void SetFormattedText(RichTextLabel richTextLabel, string locPath)
    {
        SetFormattedText((x) => richTextLabel.SetMessage(x), (x) => richTextLabel.Text = x, locPath);
    }

    private void SetFormattedText(Tooltip tooltip, string locPath)
    {
        SetFormattedText(tooltip.SetMessage, (x) => tooltip.Text = x, locPath);
    }
}
