// Â© SS220, An EULA/CLA with a hosting restriction, full text: https://raw.githubusercontent.com/SerbiaStrong-220/space-station-14/master/CLA.txt

using System.Numerics;
using Content.Shared.SS220.Surgery;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;

namespace Content.Client.SS220.Surgery.SurgeryStartUi;

[GenerateTypedNameReferences]
public sealed partial class SurgeryPuppetBox : Control
{
    /// <summary>
    /// First argument is current part, second is previous
    /// </summary>
    public event Action<PuppetParts?, PuppetParts?>? SelectedPartChanged;

    public Vector2 Scale
    {
        get => _scale;
        set
        {
            _scale = value;
            ResizeAll();
        }
    }

    private Vector2 _scale = new Vector2(1f);

    public PuppetParts? SelectedPart
    {
        get => _selectedPart;
        set
        {
            _selectedPart = HighlightPuppetPart(value);
        }
    }

    private PuppetParts? _selectedPart;

    private SortedDictionary<PuppetParts, TextureRect> _parts = new();
    private SortedDictionary<PuppetParts, TextureRect> _highlightedPart = new();
    private List<PuppetButton> _partButtons = new();

    private const string TexturePath = "/Textures/SS220/Interface/Surgery/puppet";
    private Vector2 _baseTextureSize = new(42f, 42f);

    public SurgeryPuppetBox()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);
    }

    public void Initialize()
    {
        foreach (var part in Enum.GetValues<PuppetParts>())
        {
            var textPart = MakePuppetPartButton(part, _parts, GetPuppetPartTexturePath);

            if (textPart != null)
                this.AddChild(textPart);

            textPart = MakePuppetPartButton(part, _highlightedPart, GetPuppetPartSelectedTexturePath);

            if (textPart != null)
            {
                this.AddChild(textPart);
                textPart.Visible = false;
            }

            var button = MakePuppetPartButton(part);

            if (button != null)
                AddChild(button);
        }

        ResizeAll();
    }

    private Control? MakePuppetPartButton(PuppetParts part, SortedDictionary<PuppetParts, TextureRect> bodyPartTexture, Func<PuppetParts, string?> pathSpecifier)
    {
        var partTexturePath = pathSpecifier(part);

        if (partTexturePath == null)
            return null;

        var texture = new TextureRect
        {
            Stretch = TextureRect.StretchMode.Keep,
            TexturePath = partTexturePath
        };

        bodyPartTexture.Add(part, texture);

        return texture;
    }

    private Control? MakePuppetPartButton(PuppetParts part)
    {
        var offset = GetPartOffset(part);
        var size = GetPartSize(part);

        if (offset == null || size == null)
            return null;

        var thickness = GetPartThickness(offset.Value, size.Value, Scale);

        var button = new PuppetButton
        {
            Part = part,
            SetSize = size.Value * Scale,
            Margin = thickness,
        };

        button.OnPressed += (_) =>
        {
            SelectedPart = part;
        };

        return button;
    }

    private void ResizeAll()
    {
        foreach (var texture in _parts.Values)
        {
            texture.TextureScale = _scale;
        }
        foreach (var texture in _highlightedPart.Values)
        {
            texture.TextureScale = _scale;
        }
        foreach (var button in _partButtons)
        {
            var size = GetPartSize(button.Part);
            var offset = GetPartOffset(button.Part);

            if (size == null || offset == null)
                return;

            button.Margin = GetPartThickness(offset.Value, size.Value, Scale);
            button.SetSize = size.Value * Scale;
        }
        Background.TextureScale = _scale;
    }

    /// <summary>
    /// I hope no one else will need to give a fck what happens here. God bless new med.
    /// </summary>
    private PuppetParts? HighlightPuppetPart(PuppetParts? puppetPartClicked)
    {
        var newHighlightPart = puppetPartClicked;
        switch (puppetPartClicked)
        {
            case PuppetParts.Head:
                switch (_selectedPart)
                {
                    case PuppetParts.Head:
                        newHighlightPart = PuppetParts.Eyes;
                        break;
                    case PuppetParts.Eyes:
                        newHighlightPart = PuppetParts.Mouth;
                        break;
                    case PuppetParts.Mouth:
                        newHighlightPart = PuppetParts.Head;
                        break;
                    default:
                        break;
                }
                break;
            default:
                break;
        }

        if (newHighlightPart == _selectedPart)
            return _selectedPart;

        if (_selectedPart != null)
            RemoveHighlight(_selectedPart.Value);

        if (newHighlightPart != null)
            MakeHighlighted(newHighlightPart.Value);

        SelectedPartChanged?.Invoke(newHighlightPart, _selectedPart);

        return newHighlightPart;
    }

    private void MakeHighlighted(PuppetParts part)
    {
        if (_highlightedPart.TryGetValue(part, out var newTextureControl))
            newTextureControl.Visible = true;
        if (_parts.TryGetValue(part, out var oldTextureControl))
            oldTextureControl.Visible = false;
    }

    private void RemoveHighlight(PuppetParts part)
    {
        if (_highlightedPart.TryGetValue(part, out var newTextureControl))
            newTextureControl.Visible = false;
        if (_parts.TryGetValue(part, out var oldTextureControl))
            oldTextureControl.Visible = true;
    }


    /// <summary> If you still think why we need new med to make surgery just look into this method. </summary>
    private string? GetPuppetPartTexturePath(PuppetParts puppetPart)
    {
        var state = puppetPart switch
        {
            PuppetParts.Head => "head.png",
            PuppetParts.Torso => "torso.png",
            PuppetParts.LeftArm => "left_arm.png",
            PuppetParts.RightArm => "right_arm.png",
            PuppetParts.LeftHand => "left_hand.png",
            PuppetParts.RightHand => "right_hand.png",
            PuppetParts.LeftLeg => "left_leg.png",
            PuppetParts.RightLeg => "right_leg.png",
            PuppetParts.LeftFoot => "left_foot.png",
            PuppetParts.RightFoot => "right_foot.png",
            PuppetParts.LowerTorso => "butt.png",
            _ => null
        };

        if (state == null)
            return null;
        return $"{TexturePath}/{state}";
    }

    /// <summary> If you still think why we need newMed to make surgery just look into this method too. </summary>
    private string? GetPuppetPartSelectedTexturePath(PuppetParts highlightedPuppetPart)
    {
        var state = highlightedPuppetPart switch
        {
            PuppetParts.Head => "head_selected.png",
            PuppetParts.Eyes => "eyes_selected.png",
            PuppetParts.Mouth => "mouth_selected.png",
            PuppetParts.Torso => "torso_selected.png",
            PuppetParts.LeftArm => "left_arm_selected.png",
            PuppetParts.RightArm => "right_arm_selected.png",
            PuppetParts.LeftHand => "left_hand_selected.png",
            PuppetParts.RightHand => "right_hand_selected.png",
            PuppetParts.LeftLeg => "left_leg_selected.png",
            PuppetParts.RightLeg => "right_leg_selected.png",
            PuppetParts.LeftFoot => "left_foot_selected.png",
            PuppetParts.RightFoot => "right_foot_selected.png",
            PuppetParts.LowerTorso => "butt_selected.png",
            _ => null
        };

        if (state == null)
            return null;
        return $"{TexturePath}/{state}";
    }

    private Vector2? GetPartSize(PuppetParts part)
    {
        return part switch
        {
            PuppetParts.Head => new Vector2(9, 7),
            PuppetParts.Torso => new Vector2(9f, 9f),
            PuppetParts.RightArm => new Vector2(4f, 6f),
            PuppetParts.RightHand => new Vector2(4f, 4f),
            PuppetParts.LeftArm => new Vector2(4f, 6f),
            PuppetParts.LeftHand => new Vector2(4f, 4f),
            PuppetParts.LeftLeg => new Vector2(4f, 7f),
            PuppetParts.LeftFoot => new Vector2(6f, 3f),
            PuppetParts.RightLeg => new Vector2(4f, 7f),
            PuppetParts.RightFoot => new Vector2(6f, 3f),
            PuppetParts.LowerTorso => new Vector2(9f, 4f),
            _ => null
        };
    }

    private Vector2? GetPartOffset(PuppetParts part)
    {
        return part switch
        {
            PuppetParts.Head => new Vector2(16f, 6f),
            PuppetParts.Torso => new Vector2(16f, 13f),
            PuppetParts.RightArm => new Vector2(12f, 15f),
            PuppetParts.RightHand => new Vector2(12f, 21f),
            PuppetParts.LeftArm => new Vector2(25f, 15f),
            PuppetParts.LeftHand => new Vector2(26f, 21f),
            PuppetParts.LeftLeg => new Vector2(21f, 26f),
            PuppetParts.LeftFoot => new Vector2(21f, 32f),
            PuppetParts.RightLeg => new Vector2(16f, 26f),
            PuppetParts.RightFoot => new Vector2(14f, 32f),
            PuppetParts.LowerTorso => new Vector2(16f, 22f),
            _ => null
        };
    }

    private Thickness GetPartThickness(Vector2 offset, Vector2 size, Vector2 scale)
    {
        var trueTextureSize = _baseTextureSize * scale;
        Vector2 otherMargin = trueTextureSize - (offset + size) * scale;
        return new Thickness(offset.X * scale.X, offset.Y * scale.Y, otherMargin.X, otherMargin.Y);
    }
    private Thickness GetPartThickness(Vector2 offset, Vector2 size)
    {
        return GetPartThickness(offset, size, Scale);
    }
}

public sealed class PuppetButton : BaseButton
{
    public PuppetParts Part;
}


