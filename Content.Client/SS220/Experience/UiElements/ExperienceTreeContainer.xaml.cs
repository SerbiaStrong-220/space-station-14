// Â© SS220, An EULA/CLA with a hosting restriction, full text: https://raw.githubusercontent.com/SerbiaStrong-220/space-station-14/master/CLA.txt

using System.Linq;
using System.Text;
using Content.Client.SS220.Experience.Ui;
using Content.Shared.FixedPoint;
using Content.Shared.SS220.Experience;
using Content.Shared.SS220.Experience.Systems;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;
using Robust.Shared.Utility;

namespace Content.Client.SS220.Experience.UiElements;

[GenerateTypedNameReferences]
public sealed partial class ExperienceTreeContainer : BoxContainer
{
    [Dependency] private readonly IPrototypeManager _prototype = default!;

    public event Action<BaseButton.ButtonEventArgs>? OnAddSubLevelPressed;

    // common
    private ResPath _fullBarResPath = new ResPath("/Textures/SS220/Interface/ExperienceView/full-bar.png");
    private ResPath _emptyBarResPath = new ResPath("/Textures/SS220/Interface/ExperienceView/empty-bar.png");

    private Color _unavailableLevelColor = Color.Red;
    private Color _gainedLevelColor = Color.Green;

    private ShaderInstance _subLevelFillingShaderInstance;
    private ShaderInstance _levelFillingShaderInstance;

    private readonly ProtoId<ShaderPrototype> _fillingShaderProto = "HorizontalSpriteFill";

    // general info
    private int _numberOfSublevels;
    private ResPath? _skillIconResPath = null;
    private string _skillTreeName = string.Empty;
    private List<ProtoId<SkillPrototype>> _skillsTree = [];
    // skill info
    private int _currentLevel;
    private int _currentSubLevel;
    // override skill info
    private int? _overrideLevel = null;
    // progress
    private FixedPoint4 _progress;
    // level up data (TODO)
    private bool _haveFreePoints = true;

    public ExperienceTreeContainer()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        _subLevelFillingShaderInstance = _prototype.Index(_fillingShaderProto).InstanceUnique();
        _levelFillingShaderInstance = _prototype.Index(_fillingShaderProto).InstanceUnique();

        Margin = ExperienceUiStyleDefinitions.BaseTabLikeThickness;

        ShowSubLevelsButton.OnPressed += (_) =>
            SubdataContainer.Visible = !SubdataContainer.Visible;

        // TODO visuals
        SubmitButton.OnPressed += (args) => OnAddSubLevelPressed?.Invoke(args);
    }

    public void SetInfo(ProtoId<SkillTreePrototype> protoId, SkillTreeExperienceContainer skillInfo, FixedPoint4 progress)
    {
        UnpackSkillTreeInfo(skillInfo);
        UnpackTreeProto(protoId);

        UnpackSkillProto(_skillsTree.ElementAt(_currentLevel));

        SetProgressAndUpdate(progress);
    }

    public void Update()
    {
        if (_skillIconResPath is not null)
            TreeIconRect.TexturePath = _skillIconResPath.Value.CanonPath;

        TreeName.SetMessage(_skillTreeName);
        InfoContainer.TooltipSupplier = MakeTooltip;

        var resultLevel = _overrideLevel is null ? _currentLevel : _overrideLevel.Value;

        TreeLevelsContainer.RemoveAllChildren();
        for (var i = 0; i < _skillsTree.Count; i++)
        {
            var color = GetColorForLevel(ref i);

            if (i < resultLevel)
                TreeLevelsContainer.AddChild(GetVisualRect(1f, 1f, 0f, color));
            else if (i > resultLevel)
                TreeLevelsContainer.AddChild(GetVisualRect(0f, 1f, 0f, color));
            else
                TreeLevelsContainer.AddChild(GetVisualRect(_currentSubLevel, _numberOfSublevels, 0f, color, _levelFillingShaderInstance));
        }

        SublevelsContainer.RemoveAllChildren();
        for (var i = 0; i < _numberOfSublevels; i++)
        {
            if (i < _currentSubLevel)
                SublevelsContainer.AddChild(GetExperienceSublevelVisualRect(ExperienceSystem.EndLearningProgress));
            else if (i > _currentSubLevel)
                SublevelsContainer.AddChild(GetExperienceSublevelVisualRect(ExperienceSystem.StartLearningProgress));
            else
                SublevelsContainer.AddChild(GetExperienceSublevelVisualRect(_progress, shader: _subLevelFillingShaderInstance));
        }

        SubmitButton.Visible = _haveFreePoints;
    }

    public void SetProgressAndUpdate(FixedPoint4 progress)
    {
        _progress = progress;

        Update();
    }

    private void UnpackSkillTreeInfo(SkillTreeExperienceContainer skillContainer)
    {
        var skillInfo = skillContainer.Info;
        _currentLevel = skillInfo.SkillStudied ? skillInfo.SkillLevel : Math.Max(skillInfo.SkillLevel - 1, 0);
        _currentSubLevel = skillInfo.SkillSublevel;

        _overrideLevel = null;

        if (skillContainer.OverrideInfo is null)
            return;

        var overrideSkillInfo = skillContainer.OverrideInfo;

        _overrideLevel = overrideSkillInfo.SkillStudied ? overrideSkillInfo.SkillLevel : Math.Max(overrideSkillInfo.SkillLevel - 1, 0);
    }

    private void UnpackTreeProto(ProtoId<SkillTreePrototype> protoId)
    {
        if (_prototype is null)
            return;

        var proto = _prototype.Index(protoId);

        _skillsTree = proto.SkillTree;
        _skillTreeName = Loc.GetString(proto.SkillTreeName);
    }

    private void UnpackSkillProto(ProtoId<SkillPrototype> protoId)
    {
        if (_prototype is null)
            return;

        var proto = _prototype.Index(protoId);

        _numberOfSublevels = proto.LevelInfo.MaximumSublevel;
        _skillIconResPath = proto.LevelDescription.SkillIconResPath;
    }

    private Control? MakeTooltip(Control hover)
    {
        var resultLevel = _overrideLevel is null ? _currentLevel : _overrideLevel.Value;

        if (_prototype is null)
            return null;

        var proto = _prototype.Index(_skillsTree.ElementAt(resultLevel));

        StringBuilder builder = new();

        builder.AppendLine(Loc.GetString(proto.LevelDescription.SkillName));

        if (proto.LevelDescription.SkillHoverOverrideDescription is not null)
            builder.Append(Loc.GetString(proto.LevelDescription.SkillHoverOverrideDescription));
        else
            builder.Append(Loc.GetString(proto.LevelDescription.SkillDescription));

        hover.ToolTip = builder.ToString();

        return ExperienceUiStyleDefinitions.RichExperienceTooltip(hover);
    }

    private TextureRect GetExperienceSublevelVisualRect(FixedPoint4 fillingRatio, Color? color = null, in ShaderInstance? shader = null)
    {
        return GetVisualRect(fillingRatio.Float(), ExperienceSystem.EndLearningProgress.Float(), ExperienceSystem.StartLearningProgress.Float(), color, shader);
    }

    private TextureRect GetVisualRect(float fillingRatio, float endValue, float firstValue, Color? color = null, in ShaderInstance? shader = null)
    {
        var control = new TextureRect();

        control.ModulateSelfOverride = color;

        if (fillingRatio == endValue)
        {
            control.TexturePath = _fullBarResPath.CanonPath;
            control.ShaderOverride = null;
            return control;
        }

        if (fillingRatio == firstValue)
        {
            control.TexturePath = _emptyBarResPath.CanonPath;
            control.ShaderOverride = null;
            return control;
        }

        var background = new TextureRect
        {
            TexturePath = _emptyBarResPath.CanonPath,
            HorizontalAlignment = HAlignment.Center,
            VerticalAlignment = VAlignment.Center
        };

        control.AddChild(background);
        shader?.SetParameter("Fillness", (fillingRatio + firstValue) / (endValue - firstValue));
        control.ShaderOverride = shader;
        control.TexturePath = _fullBarResPath.CanonPath;

        return control;
    }

    private Color? GetColorForLevel(ref int levelToDraw)
    {
        if (_overrideLevel is null)
            return null;

        if (levelToDraw > _currentLevel && levelToDraw < _overrideLevel)
            return _gainedLevelColor;

        if (levelToDraw < _currentLevel && levelToDraw > _overrideLevel)
            return _unavailableLevelColor;

        return null;
    }
}
