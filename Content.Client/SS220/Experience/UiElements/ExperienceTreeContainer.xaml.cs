// Â© SS220, An EULA/CLA with a hosting restriction, full text: https://raw.githubusercontent.com/SerbiaStrong-220/space-station-14/master/CLA.txt

using System.Linq;
using System.Text;
using Content.Client.SS220.Experience.Ui;
using Content.Shared.FixedPoint;
using Content.Shared.SS220.Experience;
using Content.Shared.SS220.Experience.Systems;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Prototypes;
using Robust.Shared.Utility;

namespace Content.Client.SS220.Experience.UiElements;

[GenerateTypedNameReferences]
public sealed partial class ExperienceTreeContainer : BoxContainer
{
    [Dependency] private readonly IPrototypeManager _prototype = default!;

    public Action? OnAddSublevelPoint;

    // common
    private ResPath _fullBarResPath = new ResPath("/Textures/SS220/Interface/ExperienceView/full-bar.png");
    private ResPath _emptyBarResPath = new ResPath("/Textures/SS220/Interface/ExperienceView/empty-bar.png");

    private Color _unavailableLevelColor = Color.Red;
    private Color _gainedLevelColor = Color.Green;

    private ShaderInstance _subLevelFillingShaderInstance;
    private ShaderInstance _levelFillingShaderInstance;

    private readonly ProtoId<ShaderPrototype> _fillingShaderProto = "HorizontalSpriteFill";

    // general info
    public ProtoId<SkillTreePrototype> SkillTreeId { private set; get; }

    private SkillTreeInfo? _info;
    private SkillTreeInfo? _overrideInfo;

    private string _skillTreeName = string.Empty;
    private List<int> _maxLevels = [];
    private List<ResPath?> _skillIconResPaths = new();
    private List<ProtoId<SkillPrototype>> _skillsTree = [];

    // progress
    private FixedPoint4 _progress;

    // free points spend info
    public bool HaveFreePoints
    {
        get => _haveFreePoints;
        set
        {
            _haveFreePoints = value;
            Update();
        }
    }
    private bool _haveFreePoints = false;

    public int SpendPoints
    {
        get => _spendPoints;
        set
        {
            _spendPoints = value;
            Update();
        }
    }
    private int _spendPoints;

    public bool OpenedByUser { get; private set; } = false;

    public ExperienceTreeContainer()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        _subLevelFillingShaderInstance = _prototype.Index(_fillingShaderProto).InstanceUnique();
        _levelFillingShaderInstance = _prototype.Index(_fillingShaderProto).InstanceUnique();

        Margin = ExperienceUiStyleDefinitions.BaseTabLikeThickness;

        ShowSubLevelsButton.OnPressed += (_) =>
        {
            OpenedByUser = !SubdataContainer.Visible;
            SubdataContainer.Visible = !SubdataContainer.Visible;
        };

        // TODO visuals
        AddSublevelPoint.OnPressed += (args) =>
        {
            OnAddSublevelPoint?.Invoke();
            SpendPoints++;
            Update();
        };
    }

    public void SetInfo(ref SkillTreeView view)
    {
        SpendPoints = 0;

        _info = view.Info;
        _overrideInfo = view.OverrideInfo;

        UnpackTreeProto(view.SkillTreeId);

        SetProgressAndUpdate(view.Progress);
    }

    public void Update()
    {
        if (_info is null)
            return;

        var correctInfo = _overrideInfo is null ? GetSkillTreeInfoWithSpendPoints(_info) : _overrideInfo;

        TreeName.SetMessage(_skillTreeName);
        InfoContainer.TooltipSupplier = (sender) => MakeTooltip(sender, correctInfo);

        var maxSublevels = _maxLevels[correctInfo.SkillTreeIndex];

        if (_skillIconResPaths[correctInfo.SkillTreeIndex] is { } skillIcon)
            TreeIconRect.TexturePath = skillIcon.CanonPath;

        TreeLevelsContainer.RemoveAllChildren();
        for (var i = 0; i < _skillsTree.Count; i++)
        {
            var color = GetColorForLevel(i, correctInfo);

            if (i < correctInfo.Level)
                TreeLevelsContainer.AddChild(GetVisualRect(1f, 1f, 0f, color));
            else if (i > correctInfo.Level)
                TreeLevelsContainer.AddChild(GetVisualRect(0f, 1f, 0f, color));
            else
                TreeLevelsContainer.AddChild(GetVisualRect(correctInfo.Sublevel, maxSublevels, 0f, color, _levelFillingShaderInstance));
        }

        SublevelsContainer.RemoveAllChildren();
        for (var i = 0; i < maxSublevels; i++)
        {
            if (i < correctInfo.Sublevel)
                SublevelsContainer.AddChild(GetExperienceSublevelVisualRect(ExperienceSystem.EndLearningProgress));
            else if (i > correctInfo.Sublevel)
                SublevelsContainer.AddChild(GetExperienceSublevelVisualRect(ExperienceSystem.StartLearningProgress));
            else
                SublevelsContainer.AddChild(GetExperienceSublevelVisualRect(_progress, shader: _subLevelFillingShaderInstance));
        }

        SpendPointsShower.Visible = _haveFreePoints;
        AddSublevelPoint.Visible = _haveFreePoints;

        SpendPointsShower.SetMessage(Loc.GetString("experience-tree-container-spend-points", ("SpendPointsSign", int.Sign(SpendPoints)), ("SpendPoints", SpendPoints)));
    }

    public void SetProgressAndUpdate(FixedPoint4 progress)
    {
        _progress = progress;

        Update();
    }

    private void UnpackTreeProto(ProtoId<SkillTreePrototype> protoId)
    {
        var proto = _prototype.Index(protoId);

        SkillTreeId = protoId;

        _skillsTree = proto.SkillTree;
        _maxLevels = proto.SkillTree.Select(x => _prototype.Index(x).LevelInfo.MaximumSublevel).ToList();
        _skillIconResPaths = proto.SkillTree.Select(x => _prototype.Index(x).LevelDescription.SkillIconResPath).ToList();
        _skillTreeName = Loc.GetString(proto.SkillTreeName);
    }

    private Control? MakeTooltip(Control hover, SkillTreeInfo info)
    {
        var proto = _prototype.Index(_skillsTree[info.SkillTreeIndex]);

        StringBuilder builder = new();

        builder.AppendLine(Loc.GetString(proto.LevelDescription.SkillName));

        if (proto.LevelDescription.SkillHoverOverrideDescription is not null)
            builder.Append(Loc.GetString(proto.LevelDescription.SkillHoverOverrideDescription));
        else
            builder.Append(Loc.GetString(proto.LevelDescription.SkillDescription));

        hover.ToolTip = builder.ToString();

        return ExperienceUiStyleDefinitions.RichExperienceTooltip(hover);
    }

    private TextureRect GetExperienceSublevelVisualRect(FixedPoint4 fillingRatio, Color? color = null, in ShaderInstance? shader = null)
    {
        return GetVisualRect(fillingRatio.Float(), ExperienceSystem.EndLearningProgress.Float(), ExperienceSystem.StartLearningProgress.Float(), color, shader);
    }

    private TextureRect GetVisualRect(float fillingRatio, float endValue, float firstValue, Color? color = null, in ShaderInstance? shader = null)
    {
        var control = new TextureRect();

        control.ModulateSelfOverride = color;

        if (fillingRatio == endValue)
        {
            control.TexturePath = _fullBarResPath.CanonPath;
            control.ShaderOverride = null;
            return control;
        }

        if (fillingRatio == firstValue)
        {
            control.TexturePath = _emptyBarResPath.CanonPath;
            control.ShaderOverride = null;
            return control;
        }

        var background = new TextureRect
        {
            TexturePath = _emptyBarResPath.CanonPath,
            HorizontalAlignment = HAlignment.Center,
            VerticalAlignment = VAlignment.Center
        };

        control.AddChild(background);

        if (shader != null)
        {
            var uniqueShader = shader.Duplicate();

            var fillness = (fillingRatio - firstValue) / (endValue - firstValue);
            uniqueShader.SetParameter("Fillness", fillness);

            control.ShaderOverride = uniqueShader;
        }

        control.TexturePath = _fullBarResPath.CanonPath;

        return control;
    }

    private Color? GetColorForLevel(int levelToDraw, SkillTreeInfo info)
    {
        if (_overrideInfo is null)
            return null;

        if (levelToDraw > info.Level && levelToDraw < _overrideInfo.Level)
            return _gainedLevelColor;

        if (levelToDraw < info.Level && levelToDraw > _overrideInfo.Level)
            return _unavailableLevelColor;

        return null;
    }

    private SkillTreeInfo GetSkillTreeInfoWithSpendPoints(SkillTreeInfo info)
    {
        if (SpendPoints == 0)
            return info;

        var newInfo = new SkillTreeInfo();

        var newLevel = info.SkillTreeIndex;
        var newSublevel = info.Sublevel + SpendPoints;

        while (newLevel < _maxLevels.Count && newSublevel >= _maxLevels[newLevel])
        {
            newSublevel -= _maxLevels[newLevel] - ExperienceSystem.StartSublevel;
            newLevel++;
        }

        // return from index to Level
        newLevel = Math.Min(newLevel + 1, _skillsTree.Count);

        newInfo.Level = newLevel;
        newInfo.Sublevel = newSublevel;

        return newInfo;
    }
}
